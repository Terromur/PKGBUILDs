diff --git a/src/d3d11/d3d11_context.cpp b/src/d3d11/d3d11_context.cpp
--- a/src/d3d11/d3d11_context.cpp
+++ b/src/d3d11/d3d11_context.cpp
@@ -5510,9 +5510,9 @@
       // Write the data directly to the CS chunk.
-       uint32_t dwordCount = Length / sizeof(uint32_t);
+	uint64_t dwordCount = Length / sizeof(uint64_t);
 
-      EmitCsCmd<uint32_t>(D3D11CmdType::None, dwordCount, [
+      EmitCsCmd<uint64_t>(D3D11CmdType::None, dwordCount, [
         cBufferSlice = std::move(bufferSlice)
-      ] (DxvkContext* ctx, const uint32_t* data, size_t) {
+      ] (DxvkContext* ctx, const uint64_t* data, size_t) {
         ctx->updateBuffer(
           cBufferSlice.buffer(),
           cBufferSlice.offset(),
@@ -5521,11 +5521,11 @@
 
       // Compiler should be able to vectorize here, but GCC only does
       // if we cast the destination pointer to the correct type first
-      auto src = reinterpret_cast<const uint32_t*>(pSrcData);
-      auto dst = reinterpret_cast<uint32_t*>(m_csData->first());
+      auto src = reinterpret_cast<const uint64_t*>(pSrcData);
+      auto dst = reinterpret_cast<uint64_t*>(m_csData->first());
 
-      for (uint32_t i = 0; i < dwordCount; i++)
-        new (dst + i) uint32_t(src[i]);
+      for (uint64_t i = 0; i < dwordCount; i++)
+        new (dst + i) uint64_t(src[i]);
     } else {
       // Write directly to a staging buffer and dispatch a copy
       DxvkBufferSlice stagingSlice = AllocStagingBuffer(Length);
